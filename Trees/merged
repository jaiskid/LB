/*-- File: Bottomview.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void bottomup(node*root) {
	map<int, int> m;
	queue<pair<node*, int>>q;
	q.push(make_pair(root, 0));
	while (!q.empty()) {
		pair<node*, int> curr = q.front();
		q.pop();
		m[curr.second] = curr.first->data;
		if (curr.first->left) {
			q.push(make_pair(curr.first->left, curr.second - 1));
		}
		if (curr.first->right) {
			q.push(make_pair(curr.first->right, curr.second + 1));
		}
	}
	for (auto val : m) {
		cout << val.second << " ";
	}
}
int main() {
	node*root = buildtree();
	bottomup(root);
}
/*-- File: Bottomview.cpp end --*/
/*-- File: BracketTree.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
int findIndex(string str, int start, int end) {
	if (start > end) {
		return -1;
	}
	stack<char>s;
	for (int i = start; i <= end; i++) {
		if (str[i] == '(')
			s.push(str[i]);
		else if (str[i] == ')') {
			if (s.top() == '(') {
				s.pop();
				if (s.empty())
					return i;
			}
		}
	}
	return -1;
}
node* buildtreeFromString(string s, int start, int end) {
	if (start > end) {
		return NULL;
	}
	node* root = new node(s[start] - '0');
	int index = -1;
	if (start + 1 <= end and s[start + 1] == '(') {
		index = findIndex(s, start + 1, end);
	}
	if (index != -1) {
		root->left = buildtreeFromString(s, start + 2, index - 1);
		root->right = buildtreeFromString(s, index + 2, end - 1);
	}
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
int main() {
	string s;
	cin >> s;
	node*root = buildtreeFromString(s, 0, s.size() - 1);
	print(root);
}
/*-- File: BracketTree.cpp end --*/
/*-- File: ConstructPreIn.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
int search(int *in, int start, int end, int value) {
	int i;
	for (i = start; i <= end; i++) {
		if (in[i] == value) {
			break;
		}
	}
	return i;
}
node* construct(int *pre, int *in , int start, int end) {
	static int preindex = 0;
	if (start > end) {
		return NULL;
	}

	node *root = new node(pre[preindex++]);
	if (start == end) {
		return root;
	}
	int index = search(in, start, end, root->data);
	root->left = construct(pre, in, start, index - 1);
	root->right = construct(pre, in, index + 1, end);
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	print(root->left);
	
	print(root->right);
	cout << root->data << " ";
}
int main(int argc, char const *argv[])
{
	int n;
	cin >> n;
	int pre[n];
	int	in[n];
	for (int i = 0; i < n; i++) {
		cin >> pre[i];
	}
	for (int i = 0; i < n; i++) {
		cin >> in[i];
	}
	node* root = construct(pre, in, 0, n - 1);
	print(root);
	return 0;
}
/*-- File: ConstructPreIn.cpp end --*/
/*-- File: DiagonalIterative.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void diagonal(node*root) {
	if (root == NULL) {
		return;
	}
	queue<node*> q;
	q.push(root);
	q.push(NULL);
	while (!q.empty()) {
		node*temp = q.front();
		q.pop();
		if (temp == NULL) {
			if (q.empty())
				return;
			cout << endl;
			q.push(NULL);
		}
		else {
			while (temp) {
				cout << temp->data << " ";
				if (temp->left)
					q.push(temp->left);
				temp = temp->right;
			}
		}
	}
}
int main() {
	node*root = buildtree();
	diagonal(root);
}
/*-- File: DiagonalIterative.cpp end --*/
/*-- File: Diagonial.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void diagonalPrintUntil(node*root, int d, map<int, vector<int>>&diagonalPrint) {
	if (!root) {
		return;
	}
	diagonalPrint[d].push_back(root->data);
	diagonalPrintUntil(root->left, d + 1, diagonalPrint);
	diagonalPrintUntil(root->right, d, diagonalPrint);
}
void diagonal(node*root) {
	map<int, vector<int>> diagonalPrint;
	diagonalPrintUntil(root, 0, diagonalPrint);
	for (auto val : diagonalPrint) {
		auto v = val.second;
		for (auto it : v) {
			cout << it << " ";
		}
		cout << endl;
	}
}
int main() {
	node*root = buildtree();
	diagonal(root);
}
/*-- File: Diagonial.cpp end --*/
/*-- File: Diameter.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
int height(Node* root, int& ans) 
{ 
    if (root == NULL) 
        return 0; 
  
    int left_height = height(root->left, ans); 
  
    int right_height = height(root->right, ans); 
  
    // update the answer, because diameter of a 
    // tree is nothing but maximum value of 
    // (left_height + right_height + 1) for each node 
    ans = max(ans, 1 + left_height + right_height); 
  
    return 1 + max(left_height, right_height); 
} 
  
/* Computes the diameter of binary tree with given root. */
int diameterNew(Node* root) 
{ 
    if (root == NULL) 
        return 0; 
    int ans = INT_MIN; // This will store the final answer 
    int height_of_tree = height(root, ans); 
    return ans; 
} 
// int diameter(node*root) {
// 	if (root == NULL) {
// 		return 0;
// 	}
// 	int lheight = height(root->left);
// 	int rheight = height(root->right);
// 	int ldiameter = diameter(root->left);
// 	int rdiameter = diameter(root->right);
// 	return max(lheight + rheight + 1, max(ldiameter, rdiameter));
// }
int updateDiameterCON(node*root){
	int ans = INT_MIN;

}
int main() {
	node*root = NULL;
	root = buildtree();
	print(root);
	cout << height(root);
	cout << endl;
	cout << diameter(root);
}
/*-- File: Diameter.cpp end --*/
/*-- File: DuplicatePresent.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
    int data;
    node*left, *right;
    node(int d) {
        data = d;
        left = right = NULL;
    }
};
node* buildtree() {
    int data;
    cin >> data;
    if (data == -1) {
        return NULL;
    }
    node*root = new node(data);
    root->left = buildtree();
    root->right = buildtree();
    return root;
}
string preorder(node* root, unordered_map<string, int> &mp)
{
    string s;
    if (!root)
    {
        s += "$";
        return s;
    }
    s += root->data;
    s += preorder(root->left, mp);
    s += preorder(root->right, mp);
    mp[s]++;
    return s;
}
bool dupSub(node *root)
{
    unordered_map<string, int> mp;
    preorder(root, mp);
    for (auto i : mp)
        if (i.second >= 2 && i.first.length() > 3)
            return true;
    return false;
}
int main(int argc, char const *argv[])
{
    node*root = buildtree();
    cout << dupSub(root);
    return 0;
}
/*-- File: DuplicatePresent.cpp end --*/
/*-- File: DuplicateSubtree.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node *root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}

vector<node*>v;
string preorder(node* root, unordered_map<string, int> &mp)
{
	string s;
	if (!root)
	{
		s += "X";
		return s;
	}
	s += root->data;
	s += preorder(root->left, mp);
	s += preorder(root->right, mp);
	mp[s]++;
	if (mp[s] == 2) {
		v.push_back(root);
	}
	return s;
}
// bool dupSub(Node *root)
// {
// for(auto i:mp)
//  if(i.second>=2&&i.first.length()>3)
//     return true;
//   return false;
// }
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
	cout << endl;
}
int main() {
	node*root = buildtree();
	unordered_map<string, int> mp;
	preorder(root, mp);
	for (auto x : mp) {
		cout << x.first << " " << x.second << endl;
	}
	cout << endl;
	for (auto val : v) {
		print(val);
	}
}
/*-- File: DuplicateSubtree.cpp end --*/
/*-- File: EfficientCPREIN.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node *left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildTree(int *in, int *pre, int start, int end, unordered_map<int, int>&mp) {
	static int preindex = 0;
	if (start > end) {
		return NULL;
	}
	int curr = pre[preindex++];
	node* root = new node(curr);
	if (start == end) {
		return root;
	}
	int index = mp[curr];
	root->left = buildTree(in, pre, start, index - 1, mp);
	root->right = buildTree(in, pre, index + 1, end, mp);
	return root;
}
node* buildWrap(int *in, int *pre, int n) {
	unordered_map<int, int> mp;
	for (int i = 0; i < n; i++) {
		mp[in[i]] = i;
	}
	return buildTree(in, pre, 0, n - 1, mp);
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	print(root->left);
	print(root->right);
	cout << root->data << " ";
}
int main() {
	int n;
	cin >> n;
	int in[n];
	int pre[n];
	for (int i = 0; i < n; i++) {
		cin >> in[i];
	}
	for (int i = 0; i < n; i++) {
		cin >> pre[i];
	}
	node*root = buildWrap(in, pre, n);
	print(root);
}
/*-- File: EfficientCPREIN.cpp end --*/
/*-- File: FindThesubtreeLargestsum.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
int findTheSubtree(node*root, int &ans) {
	if (root == NULL) {
		return 0;
	}
	int currsum = root->data + findTheSubtree(root->left, ans) + findTheSubtree(root->right, ans);
	ans = max(currsum, ans);
	return currsum;
}
int main() {
	node*root = buildtree();
	int ans = INT_MIN;
	cout << findTheSubtree(root, ans);
	cout << ans;
}
/*-- File: FindThesubtreeLargestsum.cpp end --*/
/*-- File: HeightTree.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
int height(node*root) {
	if (root == NULL) {
		return 0;
	}
	return max(height(root->left), height(root->right)) + 1;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
vector<int> LevelOrder(node*root) {
	queue<node*> q;
	q.push(root);
	vector<int> ans;
	while (!q.empty()) {
		node* temp = q.front();
		q.pop();
		ans.push_back(temp->data);
		if (temp->left) {
			q.push(temp->left);
		}
		if (temp->right) {
			q.push(temp->right);
		}
	}
	return ans;
}
int main() {
	node* root = NULL;
	root = buildtree();
	print(root);
	cout << height(root);
}
/*-- File: HeightTree.cpp end --*/
/*-- File: Inorder.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node *left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right =  buildtree();
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	print(root->left);
	cout << root->data << " ";
	print(root->right);

}

int main() {
	node*root = buildtree();
	print(root);
}
/*-- File: Inorder.cpp end --*/
/*-- File: InorderIterative.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void InorderIterative(node* root) {
	stack<node*> s;
	node *curr = root;
	while (!s.empty() || curr != NULL) {
		if (curr != NULL) {
			s.push(curr);
			curr = curr->left;
		}
		else {
			curr = s.top();
			s.pop();
			cout << curr->data << " ";
			curr = curr->right;
		}
	}
}
int main() {
	node*root = buildtree();
	InorderIterative(root);
}
/*-- File: InorderIterative.cpp end --*/
/*-- File: Isomorphism.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;

	if (data == -1) {
		return NULL;
	}
	node *root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
bool isomorphic(node*root1, node*root2) {
	if (root1 == NULL and root2 == NULL) {
		return true;
	}
	if (root1 == NULL || root2 == NULL) {
		return false;
	}
	if (root1->data != root2->data) {
		return false;
	}
	return (isomorphic(root1->left, root2->left) and isomorphic(root1->right, root2->right)) || (isomorphic(root1->left, root2->right) and isomorphic(root1->right, root2->left));
}
int main() {
	node*root1 = buildtree();
	node*root2 = buildtree();
	cout << isomorphic(root1, root2);
}
/*-- File: Isomorphism.cpp end --*/
/*-- File: KthAncestorBfs.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
void generateArray(node*root, int *ancestor) {
	ancestor[root->data] = -1;
	queue<node*> q;
	q.push(root);
	while (!q.empty()) {
		node*temp = q.front();
		q.pop();
		if (temp->left) {
			ancestor[temp->left->data] = temp->data;
			q.push(temp->left);
		}
		if (temp->right) {
			ancestor[temp->right->data] = temp->data;
			q.push(temp->right);
		}
	}
}
int kthAncestor(node*root, int n, int k, int nod) {
	int ancestor[n + 1] = {0};
	generateArray(root, ancestor);
	int count = 0;
	while (nod != -1) {
		nod = ancestor[nod];
		count++;
		if (count == k)
			break;
	}
	return nod;
}
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
int main() {
	node*root = buildtree();
	int n;
	cin >> n;
	int k;
	cin >> k;
	int nod;
	cin >> nod;
	cout << kthAncestor(root, n, k, nod);
}
/*-- File: KthAncestorBfs.cpp end --*/
/*-- File: KthAncestordfs.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildTree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildTree();
	root->right = buildTree();
	return root;
}
node* temp;
node* kthAncestor(node*root, int nod, int k) {
	if (!root)
		return NULL;
	if (root->data == nod || (temp = kthAncestor(root->left, nod, k)) || (temp = kthAncestor(node->right, nod, k))) {
		if (k > 0)
			k--;
		else if (k == 0) {
			cout << root->data << " ";
			return NULL;
		}
		return root;
	}
}
int main() {
	int k;
	cin >> k;
	int node;
	cin >> node;
	node *parent = kthAncestor(root, nod, k);
	if (parent)
		cout << "-1";
}

/*-- File: KthAncestordfs.cpp end --*/
/*-- File: LCA2.cpp start --*/
#include<bits/stdc++.h>
//Root to node path iski complexity toh o(n) he but ye tin baar chalta h
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
bool findPath(node*root, vector<int>&path, int k) {
	if (root == NULL) {
		return false;
	}
	path.push_back(root->data);
	if (root->data == k) {
		return true;
	}
	if (root->left and findPath(root->left, path, k) || root->right and findPath(root->right, path, k))
		return true;
	path.pop_back();
	return false;
}
int findLCA(node*root, int n1, int n2) {
	vector<int>path1, path2;
	if (!findPath(root, path1, n1) || !findPath(root, path2, n2)) {
		return -1;
	}
	int i;
	for (i = 0; i < path1.size(), i < path2.size(); i++) {
		if (path1[i] != path2[i])
			break;
	}
	return path1[i - 1];
}
int main() {
	node*root = buildtree();
	int n1;
	cin >> n1;
	int n2;
	cin >> n2;
	cout << findLCA(root, n1, n2);
}
/*-- File: LCA2.cpp end --*/
/*-- File: LeafAtSameLevel.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();

	return root;
}
bool ans;
int height(node*root) {
	if (root == NULL) {
		return 0;
	}
	int left = height(root->left);
	int right = height(root->right);
	if (root->left and root->right and left != right)
		ans = false;
	return 1 + max(left, right);
}
int main() {
	node*root = buildtree();
	ans = true;
	cout << height(root);
	cout << endl << ans;
}
/*-- File: LeafAtSameLevel.cpp end --*/
/*-- File: LeftView.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node *left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void leftviewRec(node*root, int level, int &maxlevel) {
	if (root == NULL) {
		return;
	}
	if (maxlevel < level) {
		cout << root->data << " ";
		maxlevel = level;
	}
	leftviewRec(root->left, level + 1, maxlevel);
	leftviewRec(root->right, level + 1, maxlevel);
}
void leftView(node*root) {
	int maxlevel = 0;
	leftviewRec(root, 1, maxlevel);
}
int main() {
	node*root = buildtree();
	leftView(root);
}
/*-- File: LeftView.cpp end --*/
/*-- File: LevelOrder.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = NULL;
		right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1)
		return NULL;
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
vector<int> levelorder(node*root) {
	//Use queue for level order
	queue<node*>q;
	vector<int> v;
	q.push(root);
	while (!q.empty()) {
		node*temp = q.front();
		q.pop();
		v.push_back(temp->data);
		if (temp->left) {
			q.push(root->left);
		}
		if (temp->right) {
			q.push(root->right);
		}
	}
	return v;
}
void print(node* root) {
	if (root == NULL)
		return;
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
int main() {
	node*root = NULL;
	root = buildtree();
	// print(root);
	auto val = levelorder(root);
	for (auto v : val) {
		cout << v << " ";
	}
}
/*-- File: LevelOrder.cpp end --*/
/*-- File: MaximumSumbinaryTreeNoAdj.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
int sumOfgrandChildren(node*root, map<node*, int>&mp);
int getMaxSumUtil(node*root, map<node*, int>&mp);
int sumOfgrandChildren(node*root, map<node*, int>&mp) {
	int sum = 0;
	if (root->left) {
		sum += getMaxSumUtil(root->left->left, mp) + getMaxSumUtil(root->left->right, mp);
	}
	if (root->right) {
		sum += getMaxSumUtil(root->right->right, mp) + getMaxSumUtil(root->right->left, mp);
	}
	return sum;
}
int getMaxSumUtil(node* root , map<node*, int>&mp) {
	if (root == NULL) {
		return 0;
	}
	if (mp.find(root) != mp.end()) {
		return mp[root];
	}
	int incl = root->data + sumOfgrandChildren(root, mp);
	int excl = getMaxSumUtil(root->left, mp) + getMaxSumUtil(root->right, mp);
	mp[root] = max(incl, excl);

	return mp[root];
}


int main() {
	node*root = buildtree();
	map<node*, int> mp;
	cout << getMaxSumUtil(root, mp);
}
/*-- File: MaximumSumbinaryTreeNoAdj.cpp end --*/
/*-- File: MindistanceTwonodes.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
node* findLca(node*root, int n1, int n2) {
	if (root == NULL) {
		return NULL;
	}
	if (root->data == n1 || root->data == n2) {
		return root;
	}
	node* left_root = findLca(root->left, n1, n2);
	node* right_root = findLca(root->right, n1, n2);
	if (left_root and right_root) {
		return root;
	}
	return (left_root != NULL) ? left_root : right_root;
}
int count(node*root, int val, int level) {
	if (root == NULL) {
		return -1;
	}
	if (root->data == val) {
		return level;
	}
	int d = count(root->left, val, level + 1);
	if (d != -1)
		return d;
	d = count(root->right, val, level + 1);
	return d;
}
int findDist(node*root, int a, int b) {
	if (root == NULL) {
		return 0;
	}
	node* final = findLca(root, a, b);
	int d1 = count(final, a, 0);
	int d2 = count(final, b, 0);
	return d1 + d2;
}
int main() {
	node* root = buildtree();
	int a, b;
	cin >> a >> b;
	cout << findDist(root, a, b);
}
/*-- File: MindistanceTwonodes.cpp end --*/
/*-- File: Mirror.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
void mirrorify(node*root) {
	if (root == NULL) {
		return;
	}
	mirrorify(root->left);
	mirrorify(root->right);
	swap(root->left, root->right);
}
int main() {
	node*root = NULL;
	root = buildtree();
	print(root);
	mirrorify(root);
	cout << endl;
	print(root);
}
/*-- File: Mirror.cpp end --*/
/*-- File: PostOrder.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node *left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void postorderIterative(node*root) {
	stack<node*> stk;
	stk.push(root);
	stack<int>out;
	while (!stk.empty()) {
		node*curr = stk.top();
		stk.pop();
		out.push(curr->data());
		if (curr->left) {
			stk.push(curr->left);
		}
		if (curr->right) {
			stk.push(curr->right);
		}
	}
	while (!out.empty()) {
		cout << out.top() << " ";
		out.pop();
	}
}
void print(node* root) {
	if (root == NULL) {
		return;
	}
	print(root->left);
	print(root->right);
	cout << root->data << " ";
}
int main(){
	node*root = buildtree();
	print(root);
	postorderIterative(root);
}
/*-- File: PostOrder.cpp end --*/
/*-- File: ReverseLeveLorder.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node* left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void LevelOrder(node*root) {
	queue<node*>q;
	q.push(root);
	stack<node*>S;
	while (!q.empty()) {
		node*temp = q.front();
		q.pop();
		S.push(temp);

		if (temp->right) {
			q.push(temp->right);
		}
		if (temp->left) {
			q.push(temp->left);
		}


	}
	while (!S.empty()) {
		cout << S.top()->data << " ";
		S.pop();
	}
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
int main() {
	node*root = NULL;
	root = buildtree();
	print(root);
	cout << endl;
	LevelOrder(root);
}
/*-- File: ReverseLeveLorder.cpp end --*/
/*-- File: RightView.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
void rightViewRecurr(node*root, int level, int &maxLevel) {
	if (root == NULL) {
		return;
	}
	if (maxLevel < level) {
		cout << root->data << " ";
	}
	rightViewRecurr(root->right, level + 1, maxLevel);
	rightViewRecurr(root->left, level + 1, maxLevel);
}
void rightView(node*root) {
	int maxLevel = 0;
	rightViewRecurr(root->right, 1, maxLevel);
}
int main() {
	node*root = buildtree();
	print(root);
	rightView(root);
}
/*-- File: RightView.cpp end --*/
/*-- File: SumTree.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildree();
	root->right = buildree();
	return root;
}
int tosumTree(node*root) {
	if (root == NULL) {
		return 0;
	}
	int old_data = root->data;
	root->data = tosumTree(root->left) + tosumTree(root->right);
	return root->data + old_data;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	
	print(root->left);
	cout << root->data << " ";
	print(root->right);
}
int main() {
	node*root = buildree();
	print(root);
	tosumTree(root);
	print(root);
}
/*-- File: SumTree.cpp end --*/
/*-- File: SumTreeworst.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
int sum(node*root) {
	if (root == NULL) {
		return 0;
	}
	return sum(root->left) + root->data + sum(root->right);
}
bool Sumtree(node*root) {
	if (root == NULL || root->left == NULL and root->right == NULL) {
		return true;
	}
	int ls = sum(root->left);
	int rs = sum(root->right);
	if ((root->data == ls + rs) and Sumtree(root->left) and Sumtree(root->right))
		return true;
	return false;
}
int main() {
	node*root = buildtree();
	cout << Sumtree(root);
}
/*-- File: SumTreeworst.cpp end --*/
/*-- File: Topview.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void topView(node*root) {
	queue<pair<node*, int>> q;
	map<int, int> m;
	q.push(make_pair(root, 0));
	while (!q.empty()) {
		pair<node*, int> curr = q.front();
		q.pop();
		if (m.find(curr.second) == m.end()) {
			m[curr.second] = curr.first->data;
		}
		if (curr.first->left) {
			q.push(make_pair(curr.first->left, curr.second - 1));
		}
		if (curr.first->right) {
			q.push(make_pair(curr.first->right, curr.second + 1));
		}
	}
	for (auto val : m) {
		cout << val.second << " ";
	}
}
int main() {
	node*root = buildtree();
	topView(root);
}
/*-- File: Topview.cpp end --*/
/*-- File: VerticalOrder.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
void printVerticalOrder(node* root)
{
	// Base case
	if (!root)
		return;

	// Create a map and store vertical oder in
	// map using function getVerticalOrder()
	map<int, vector<int> > m;
	int hd = 0;

	// Create queue to do level order traversal.
	// Every item of queue contains node and
	// horizontal distance.
	queue<pair<node*, int> > que;
	que.push(make_pair(root, hd));

	while (!que.empty()) {
		// pop from queue front
		pair<node*, int> temp = que.front();
		que.pop();
		hd = temp.second;
		node* node = temp.first;

		// insert this node's data in vector of hash
		m[hd].push_back(node->data);

		if (node->left != NULL)
			que.push(make_pair(node->left, hd - 1));
		if (node->right != NULL)
			que.push(make_pair(node->right, hd + 1));
	}

	// Traverse the map and print nodes at
	// every horigontal distance (hd)
	map<int, vector<int> >::iterator it;
	for (it = m.begin(); it != m.end(); it++) {
		for (int i = 0; i < it->second.size(); ++i)
			cout << it->second[i] << " ";
		cout << endl;
	}
}
int main() {
	node* root = buildtree();
	printVerticalOrder(root);
}
/*-- File: VerticalOrder.cpp end --*/
/*-- File: VerticalOrderRecursively.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
void getVerticalOrder(node*root, int hd, map<int, vector<int>>&m) {
	if (root == NULL) {
		return;
	}
	m[hd].push_back(root->data);
	getVerticalOrder(root->left, hd - 1, m);
	getVerticalOrder(root->right, hd + 1, m);
}
void printVerticalOrder(node* root) {
	map<int, vector<int>>m;
	int hd = 0;
	getVerticalOrder(root, hd, m);
	// Traverse the map and print nodes at every horigontal
	// distance (hd)
	map< int, vector<int> > :: iterator it;
	for (it = m.begin(); it != m.end(); it++)
	{
		for (int i = 0; i < it->second.size(); ++i)
			cout << it->second[i] << " ";
		cout << endl;
	}
}
int main() {
	node*root = buildtree();
	printVerticalOrder(root);
}
/*-- File: VerticalOrderRecursively.cpp end --*/
/*-- File: ZigZag.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void print(node*root) {
	if (root == NULL) {
		return;
	}
	cout << root->data << " ";
	print(root->left);
	print(root->right);
}
void zigzag(node*root) {
	node*temp;
	stack<node*> s1, s2;
	s1.push(root);
	while (!s1.empty() || !s2.empty()) {
		while (!s1.empty()) {
			temp = s1.top();
			s1.pop();
			cout << temp->data << " ";
			if (temp->left) {
				s2.push(temp->left);
			}
			if (temp->right) {
				s2.push(temp->right);
			}
		}
		while (!s2.empty()) {
			temp = s2.top();
			s2.pop();
			cout << temp->data << " ";
			if (temp->right) {
				s1.push(temp->right);
			}
			if (temp->left) {
				s1.push(temp->left);
			}
		}
	}
}
int main() {
	node*root = buildtree();
	// print(root);
	zigzag(root);
}
/*-- File: ZigZag.cpp end --*/
/*-- File: checksumtree.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
int TreeSum(node*root) {
	if (root == NULL) {
		return 0;
	}
	else if (root->left == NULL and root->right == NULL) {
		return root->data;
	}
	else {
		if (root->data == TreeSum(root->left) + TreeSum(root->right)) {
			return 2 * root->data;
		}
	}
	return 0;
}
bool isSumtree(node*root) {
	if (root->data  == TreeSum(root) / 2) {
		return 1;
	}
	else {
		return 0;
	}
}
int main() {
	node* root = buildtree();
	cout << isSumtree(root);
}
/*-- File: checksumtree.cpp end --*/
/*-- File: heightBalanced.cpp start --*/

#include<bits/stdc++.h>
using namespace std;
class node
{
public:
    int data;
    node *left, *right;
    node(int d) {
        data = d;
        left = right = NULL;
    }
};
node* buildtree() {
    int data;
    cin >> data;
    if (data == -1) {
        return NULL;
    }
    node*root = new node(data);
    root->left = buildtree();
    root->right = buildtree();
    return root;
}
int height(node* root, bool &flag) {
    if (!root) return 0;

    int l = height(root->left, flag);
    int r = height(root->right, flag);
    if (abs(l - r) > 1) flag = false;
    return 1 + max(l, r);
}

bool isBalanced(node *root)
{
    bool flag = true;
    int h = height(root, flag);
    return flag;
}
int main() {
    node*root = buildtree();
    cout << isBalanced(root);
}

/*-- File: heightBalanced.cpp end --*/
/*-- File: printAllpathsfromroot.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree()
{
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node *root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}

void printAllpathsfromroot(node*root, int sum, int sum_so_far, vector<int>&path) {
	if (root == NULL) {
		return;
	}
	sum_so_far += root->data;
	path.push_back(root->data);
	if (sum_so_far == sum) {
		for (int i = 0; i < path.size(); i++) {
			cout << path[i] << " ";
		}
		cout << endl;
	}
	if (root->left != NULL) {
		printAllpathsfromroot(root->left, sum, sum_so_far, path);
	}
	if (root->right != NULL) {
		printAllpathsfromroot(root->right, sum, sum_so_far, path);
	}
	path.pop_back();
}
int main() {
	node*root = buildtree();
	vector<int>path;
	int sum;
	cin >> sum;
	printAllpathsfromroot(root, sum, 0, path);
}
/*-- File: printAllpathsfromroot.cpp end --*/
/*-- File: printKsumpaths.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node * root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void printKPathutil(node*root, vector<int>&path, int k) {
	if (root == NULL) {
		return;
	}
	path.push_back(root->data);
	printKPathutil(root->left, path, k);
	printKPathutil(root->right, path, k);
	int f = 0;
	for (int j = path.size() - 1; j >= 0; j--) {
		f += path[j];
		if (f == k) {
			for (int i = j; i < path.size(); i++) {
				cout << path[i] << " ";
			}
			cout << endl;
		}
	}
	path.pop_back();
}
int main() {
	node*root = buildtree();
	int k;
	cin >> k;
	vector<int>path;
	printKPathutil(root, path, k);
}
/*-- File: printKsumpaths.cpp end --*/
/*-- File: singleTraversalLca.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node*left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node* root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
node* findLca(node*root, int n1, int n2) {
	if (root == NULL) {
		return NULL;
	}
	if (root->data == n1 || root->data == n2) {
		return root;
	}
	node* left_lca = findLca(root->left, n1, n2);
	node* right_lca = findLca(root->right, n1, n2);
	if (left_lca and right_lca) {
		return root;
	}
	return (left_lca != NULL) ? left_lca : right_lca;
}
int main() {
	node* root = buildtree();
	int n1, n2;
	cin >> n1 >> n2;
	cout << findLca(root, n1, n2)->data;
}
/*-- File: singleTraversalLca.cpp end --*/
/*-- File: sumoflongestpath.cpp start --*/
#include<bits/stdc++.h>
using namespace std;
class node {
public:
	int data;
	node* left, *right;
	node(int d) {
		data = d;
		left = right = NULL;
	}
};
node* buildtree() {
	int data;
	cin >> data;
	if (data == -1) {
		return NULL;
	}
	node*root = new node(data);
	root->left = buildtree();
	root->right = buildtree();
	return root;
}
void sumofLongRootToLeafPath(node*root, int sum, int len, int &maxLen, int &maxSum) {
	if (root == NULL) {
		if (maxLen < len) {
			maxLen = len;
			maxSum = sum;
		}
		else if (maxLen == len and maxSum < sum) {
			maxSum = sum;
		}
		return;
	}
	sumofLongRootToLeafPath(root->left, sum + root->data, len, maxLen, maxSum);
	sumofLongRootToLeafPath(root->right, sum + root->data, len, maxLen, maxSum);
}
int main() {
	node* root = buildtree();
	int maxLen = 0;
	int maxSum = INT_MIN;
	sumofLongRootToLeafPath(root, 0, 0, maxLen, maxSum);
	cout << maxSum;
}
/*-- File: sumoflongestpath.cpp end --*/
